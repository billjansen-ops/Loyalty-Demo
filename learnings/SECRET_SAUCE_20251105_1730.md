# SECRET SAUCE - Core Architectural Principles

**Last Updated:** 2025-11-05 17:30  
**Purpose:** The fundamental innovations and design principles that make this system special

---

## üéØ Core Architectural Principles

### 1. Temporal-First Design
**Philosophy:** Always use event time, not processing time

**Implementation:**
- Use `activity_date` for ALL logic, never `CURRENT_DATE`
- Tier lookup: `get_member_tier_on_date(member_id, activity.activity_date)`
- Points expiry: `activity_date + 24 months`
- Promotion eligibility: Checked at activity date

**Why This Is Brilliant:**
- **Retro-credit just works** - No special code needed!
- Posting a July activity in October automatically:
  - Uses July tier status
  - Applies July-active promotions
  - Sets correct expiry date
  - No "retro" flag needed

**The Test:** If retro needs special code ‚Üí temporal design is wrong. If retro just works ‚Üí architecture is sound.

---

### 2. Tiers Are Promotion Rewards
**Philosophy:** Tiers aren't status fields - they're time-bounded rewards granted by promotions

**Implementation:**
```sql
-- No status field!
-- Instead: member_tier table with start_date and end_date
CREATE TABLE member_tier (
  member_id BIGINT,
  tier_id SMALLINT,
  start_date DATE,
  end_date DATE
)
```

**How Qualification Works:**
```javascript
Promotion: "Earn Gold Status"
Condition: total_miles >= 20,000 in calendar year
Action: CREATE member_tier (
  tier_id = GOLD,
  start_date = QUALIFICATION_DATE,
  end_date = YEAR_END
)
```

**Why This Is Brilliant:**
- **Year-end transitions are automatic** - No batch job needed!
  - Dec 31 11:59 PM: `get_member_tier_on_date('2024-12-31')` ‚Üí Gold
  - Jan 1 12:00 AM: `get_member_tier_on_date('2025-01-01')` ‚Üí Basic
- Complete audit trail of all tier grants
- Multiple qualification paths supported
- Overlapping periods allowed (for retro scenarios)
- Retro-credit works perfectly (check tier on activity date)

**The Test:** If you need year-end processing ‚Üí you materialized state. If dates handle transitions ‚Üí you derived state correctly.

---

### 3. Everything Is Pointers (Performance)
**Philosophy:** Store integer foreign keys, not strings

**Size Comparison:**
```javascript
// This system - integers (4 bytes each)
{ carrier_id: 12, origin_id: 716, destination_id: 458 }
// ~50 bytes total

// Naive system - strings
{ 
  carrier: "Delta Air Lines",
  origin: "LaGuardia Airport, New York, NY", 
  destination: "Los Angeles International..."
}
// ~200+ bytes total
```

**Why It's Fast:**
- Integer joins = CPU cache friendly
- Integer indexes = tiny, stay in memory
- Integer comparisons = nanoseconds
- More rows fit in buffer cache
- Network payloads are tiny

**Application:** Bonus rules evaluate at pointer speed!

---

### 4. Data Drives Behavior (Not Hardcoded Logic)
**Philosophy:** Read metadata from database tables, never hardcode table/column names

**Wrong Approach:**
```javascript
// ‚ùå Hardcoded logic - requires code changes for new industries
if (moleculeKey === 'carrier') {
  return query('SELECT carrier_id FROM carriers WHERE code = $1', [value]);
} else if (moleculeKey === 'hotel_brand') {
  return query('SELECT brand_id FROM hotel_brands WHERE code = $1', [value]);
}
```

**Right Approach:**
```javascript
// ‚úÖ Data-driven - no code changes for new industries
const metadata = query('SELECT table_name, id_column, code_column FROM molecule_value_lookup WHERE molecule_id = $1');
return query(`SELECT ${metadata.id_column} FROM ${metadata.table_name} WHERE ${metadata.code_column} = $1`, [value]);
```

**Why This Is Brilliant:**
- Add 100 new molecule types ‚Üí zero code changes
- Industry-agnostic bonus engine
- Self-documenting (metadata IS the documentation)
- No scattered if/else logic

**The Test:** If adding a new data type requires code changes ‚Üí wrong. If it only requires database inserts ‚Üí correct.

---

### 5. Zero Batch Processing
**Philosophy:** Derive state on-demand, don't materialize it

**Examples:**
- **Tier status:** Not stored in member table, derived from member_tier query
- **Points balance:** Calculated from point_lot table when needed
- **Promotion progress:** Summed from activity contributions in real-time

**Why This Is Brilliant:**
- No year-end batch jobs
- No status field synchronization
- No scheduled recalculations
- Always accurate (no stale data)
- Simpler code (no batch job logic)

**The Test:** If you need a batch job ‚Üí you're materializing. If queries derive everything ‚Üí you're doing it right.

---

### 6. Molecule Abstraction (Universal, Industry-Agnostic)
**Philosophy:** Activity data is stored as configurable "molecules" instead of hardcoded columns

**The Problem It Solves:**
- Airlines need: carrier, origin, destination, fare_class
- Hotels need: brand, property, room_type, room_nights
- Retail needs: merchant, category, sku, quantity
- **Traditional approach:** Different tables for each industry ‚Üí fragmented codebase

**The Solution:**
- `molecule_def` - Defines WHAT molecules exist (parent table)
- `molecule_value_*` - Stores metadata and values (child tables)
- `activity_detail` - Stores transactional values (k/v pairs)
- Universal encode/decode functions transform values to integers

**The Architecture:**

```
molecule_def (parent)
‚îú‚îÄ molecule_value_lookup (for lookups like carrier, origin)
‚îÇ  ‚îî‚îÄ Stores: table_name, id_column, code_column, label_column
‚îú‚îÄ molecule_value_ref (for lists like fare_class: F/C/Y)
‚îÇ  ‚îî‚îÄ Stores: text_value, display_label, sort_order
‚îú‚îÄ molecule_value_text (for scalar text values)
‚îú‚îÄ molecule_value_numeric (for scalar numbers)
‚îú‚îÄ molecule_value_date (for scalar dates)
‚îî‚îÄ molecule_value_boolean (for scalar booleans)

activity_detail (transactional values)
‚îú‚îÄ k (molecule key like "carrier")
‚îú‚îÄ v_ref_id (integer pointer)
‚îú‚îÄ v_text (text value)
‚îú‚îÄ v_num (numeric value)
‚îî‚îÄ v_date (date value)
```

**Why This Is Brilliant:**
- **Same bonus engine evaluates airlines, hotels, retail** - Just comparing molecule values
- **Add new industries:** Insert molecule definitions, no code changes
- **Pure integers:** All child records store integers (performance)
- **Text deduplication:** molecule_text_pool eliminates duplicate strings
- **Self-documenting:** Molecule definitions ARE the documentation

---

## üß¨ The Molecule System (Detailed)

### Molecule Types

**1. LOOKUP molecules** (carrier, origin, destination)
- Value stored as: Integer FK to external table (carrier_id, airport_id)
- Metadata in: `molecule_value_lookup`
- Transactional storage: `activity_detail.v_ref_id`
- Example: "DL" ‚Üí 7 (carrier_id in carriers table)

**2. LIST molecules** (fare_class)
- Value stored as: Integer FK to molecule_value_ref
- Valid options in: `molecule_value_ref` (F, C, Y with display labels)
- Transactional storage: `activity_detail.v_ref_id`
- Example: "C" ‚Üí 42 (value_id in molecule_value_ref)

**3. SCALAR molecules** (flight_number, confirmation_code)
- **Numeric:** Stored directly as integer
- **Text:** Stored in `molecule_text_pool` (deduplicated)
- **Static:** Stored in `molecule_value_text/_numeric/_date/_boolean`
- **Transactional:** Stored in `activity_detail.v_text/v_num/v_date`

### Universal Encode/Decode Functions

```javascript
encodeMolecule(tenantId, key, value) ‚Üí integer
// "MSP" ‚Üí 17 (airport_id)
// "DL" ‚Üí 7 (carrier_id)
// "C" ‚Üí 42 (value_id for Business class)
// "ABC123" ‚Üí 1 (text_id in molecule_text_pool)
// 1247 ‚Üí 1247 (numeric pass-through)

decodeMolecule(tenantId, key, id) ‚Üí value
// 17 ‚Üí "MSP" (query airports table)
// 7 ‚Üí "DL" (query carriers table)
// 42 ‚Üí "C" (query molecule_value_ref)
// 1 ‚Üí "ABC123" (query molecule_text_pool)
// 1247 ‚Üí 1247 (numeric pass-through)
```

**Key Innovation:** Application code never needs to know which table, which type, or how to join!

### Text Pool Deduplication

**First Entry:**
```
encodeMolecule(1, 'confirmation_code', 'ABC123')
‚Üí Inserts into molecule_text_pool: text_id=1, usage_count=1
```

**Second Entry (same text):**
```
encodeMolecule(1, 'confirmation_code', 'ABC123')
‚Üí Finds text_id=1, increments usage_count=2
```

**Benefits:**
- 1000 flights with same confirmation ‚Üí only 1 string stored
- usage_count provides analytics
- Eliminates duplicate storage
- All child records remain pure integers

---

## üí° Why This Design Is Brilliant

### 1. Multi-Industry Platform
**Same bonus engine evaluates:**
- Airline: "Fly into LGA ‚Üí double points"
- Hotel: "Stay at Marriott properties ‚Üí double points"  
- Retail: "Purchase from Nike ‚Üí double points"

**The engine just compares molecule values:**
```javascript
Does activity.molecule[X] match criterion.value[Y]?
```

Whether X is "destination airport" or "hotel brand" doesn't matter. It's just comparing integers.

### 2. Add New Industries - Zero Code Changes
**To add automotive industry:**
1. Insert molecule definitions: vehicle_make, vehicle_model, dealer_location
2. Insert molecules into molecule_value_lookup
3. Done! Bonus engine works immediately

**No if/else branches. No hardcoded table names. Just data.**

### 3. Performance Through Pointers
- Pure integers in child records
- Cache-friendly (small payloads)
- Fast joins (integer indexes)
- Text deduplication (space savings)

### 4. Self-Documenting Metadata
- molecule_def describes itself (label, description, value_kind)
- molecule_value_lookup describes external tables (table_name, columns)
- No separate documentation needed - the data IS the documentation

### 5. Auditability
- Complete activity history with all molecule values
- Tier grants tracked in member_tier with start/end dates
- Promotion contributions tracked in promotion_detail
- Everything has created_at timestamps

---

## üìö Historical Context

### Bill's "Million Years Ago" System (1980s-90s)

**Design Philosophy:**
- Custom variable-length keys (1-4 bytes based on table needs)
- **2-byte dates:** Days since 12/31/1959 (Bill's birthday!)
  - Coverage: 1960-2139 (179 years)
  - 2 bytes instead of 8+ for full timestamps
- Right-size every field to actual domain needs
- Performance-first approach

**This thinking informs current architecture:**
- SMALLINT for tenant_id (50 tenants expected, 32K max = 655x headroom)
- Pointer-based relationships (IDs, not strings)
- Cache-friendly designs (small data types)
- Deliberate data type choices (not just "use INTEGER for everything")

**Quote:** "When the world says no, figure it out anyway."

---

## üîç Key Discoveries by Session

### October 30, 2025
- **Discovery:** Retro-credit just works (temporal design proof)
- **Discovery:** Tiers are promotion rewards (not status fields)
- **Discovery:** Promotion engine is universal reward system

### November 3, 2025
- **Discovery:** SMALLINT for tenant_id saves space at scale
- **Discovery:** Documentation format matters (always .md)
- **Learning:** Error handling in frontend fetch calls

### November 4, 2025
- **Discovery:** Molecule system is the foundation (not just activity data)
- **Discovery:** Dynamic labels via molecule values
- **Learning:** Browser caching requires version parameters

### November 5, 2025 (Morning)
- **Discovery:** Molecule model was broken (mixed types in child records)
- **Realization:** Need universal encode/decode functions
- **Discovery:** molecule_value_lookup contains metadata (not molecule_def)
- **Learning:** Always provide complete files, never ask for manual edits

### November 5, 2025 (Evening - This Session)
- **Discovery:** Need bulletproof handoff process (4 files + bootstrap templates)
- **Learning:** Separate operational knowledge (how to work) from project knowledge (what we built)
- **Learning:** WORKFLOW_STANDARDS and SECRET_SAUCE accumulate, others replace

---

## üéØ The Secret Sauce Summary

**In one sentence:** A temporal-first, data-driven, pointer-based, multi-tenant loyalty platform with universal molecule abstraction that works across any industry without code changes.

**What makes it special:**
1. Retro-credit just works (temporal design)
2. Tiers are promotion rewards (zero batch processing)
3. Everything is pointers (performance)
4. Data drives behavior (not hardcoded)
5. Molecule abstraction (industry-agnostic)
6. Self-documenting metadata
7. Text deduplication
8. Complete auditability

**The test of elegance:** Adding a new industry, new data type, or new feature should only require database inserts, not code changes.

**Bill's philosophy:** Right-size everything. Let data drive behavior. Make retro-credit a litmus test of proper temporal design.

---

**This is the foundation of a truly multi-tenant, multi-industry loyalty platform that will work for decades.**
