# SECRET SAUCE - Core Architectural Principles

**Purpose:** The fundamental truths and innovations that make this loyalty platform special.

**Note:** This file ACCUMULATES. Never remove insights - always add discoveries.

---

## Core Architectural Principles

These are the fundamental truths that guide every decision in this system:

### 1. Temporal-First Design
**Retro-credit just works.**

Activities have dates. Bonuses have date ranges. When you evaluate bonuses, you check if the activity date falls within the bonus range. This means:
- No "backdating" logic needed
- No special retro-credit processing
- No batch jobs to fix historical data
- Just query: `WHERE activity_date BETWEEN bonus_start_date AND bonus_end_date`

The system doesn't care if you're processing an activity from yesterday or 5 years ago. Time is just another dimension.

### 2. Tiers Are Promotion Rewards (Not Status Fields)
**Tier qualification is a promotion that grants a tier reward.**

Most systems think: "Member has a tier status that changes over time."

This system thinks: "Member earned a promotion that grants tier benefits for a time period."

Why this is brilliant:
- Tier becomes a time-bounded record in `member_tier` table
- Multiple concurrent tiers possible (e.g., earned Gold, challenged to Platinum)
- Tier changes are promotions, so bonus engine handles them
- Historical tier status is just `WHERE current_date BETWEEN start_date AND end_date`
- No "current tier" field to maintain - it's derived

### 3. Everything Is Pointers (Performance)
**Don't copy strings, reference them.**

- Text values stored once in `molecule_text_pool`
- Activities reference text via `text_pool_id`
- Deduplication happens automatically
- Billions of activities don't duplicate "DFW" millions of times
- Cache-friendly: Hot text values stay in memory

### 4. Data Drives Behavior (Not Hardcoded Logic)
**The database tells the code what to do, not the other way around.**

Wrong: `if (activityType === 'FLIGHT') { calculateMiles(); }`
Right: `getMolecule('distance_flown')` returns calculation rule

Wrong: `<select><option>First Class</option></select>`
Right: `getMolecule('cabin_class')` populates dropdown

The code is generic. The data is specific. This is why:
- New industries don't require code changes
- Business rules live in database, not codebase
- Non-programmers can configure behavior
- Same code serves airlines, hotels, retail

### 5. Zero Batch Processing (Derive On-Demand)
**Don't maintain aggregates - calculate them.**

Most systems: Nightly batch job updates point balances.

This system: `SELECT SUM(points) FROM point_lot WHERE member_id = X AND expiration_date > today()`

Why:
- Always accurate (no stale data)
- No batch job failures
- No reconciliation needed
- Database is fast enough
- Fewer things to break

### 6. Molecule Abstraction (Universal, Industry-Agnostic)
**The secret sauce that makes this work across any industry.**

A "molecule" is a configurable attribute that can be:
- A label (static text)
- A dropdown (list of values)
- A lookup (reference to another table)
- A calculated field (derived from other molecules)

The magic:
- Airlines use molecules for: cabin class, origin, destination, distance
- Hotels use molecules for: room type, hotel chain, city, nights
- Retail uses molecules for: product category, store, transaction amount
- **Same code, different data**

---

## The Molecule System

The molecule architecture is what makes this system universal.

### Structure

```
molecule_def (parent)
├── defines: key, label, context, type, value_kind
├── molecule_value_text (for list type, value_kind='list')
├── molecule_value_numeric (for numeric type)
├── molecule_value_boolean (for yes/no type)
├── molecule_value_date (for date type)
├── molecule_value_lookup (metadata for external tables, value_kind='lookup')
└── molecule_value_embedded_list (multi-category lists, value_kind='embedded_list')

activity_detail (transactional values)
└── links to molecule_def via molecule_id
```

### Key Tables

**molecule_def:** The parent table defining each molecule
- `molecule_key`: Human-readable key (e.g., "cabin_class")
- `label`: Display name (e.g., "Cabin Class")
- `context`: activity, member, tenant, or system
- `molecule_type`: static (config) or transactional (per-activity)
- `value_kind`: scalar, list, lookup, embedded_list
- `is_permanent`: Can't be deleted if true
- `is_required`: Must have value if true

**molecule_value_text:** For list-type molecules
- `text_value`: The code (e.g., "F")
- `display_label`: What users see (e.g., "First Class")
- `sort_order`: Display order
- Powers dropdowns in UI

**molecule_value_lookup:** Metadata for external tables
- `lookup_table_key`: Foreign table name (e.g., "carriers")
- `value_col_name`: Column with code (e.g., "carrier_code")
- `label_col_name`: Column with display name (e.g., "carrier_name")
- `is_tenant_specific`: Whether to filter by tenant_id
- Enables dynamic lookups without hardcoding

**molecule_value_embedded_list:** Multi-category lists
- `category`: Subcategory name (e.g., "redemption_type", "bonus_type")
- `code`: The value code (e.g., "F", "V")
- `description`: Display text (e.g., "Fixed", "Variable")
- `sort_order`: Display order
- One molecule (e.g., "sysparm") contains many categories
- No separate ID - composite key is (molecule_id, tenant_id, category, code)

**activity_detail:** Transactional molecule values
- `activity_id`: Which activity
- `molecule_id`: Which molecule
- `text_pool_id`: Reference to actual text value
- This is where activity-specific values live
- Enables universal activity storage

### Universal Functions

**encode(value, molecule_key):** Convert user input to pointer
- Input: "DFW", "origin_airport"
- Output: text_pool_id (e.g., 42)
- Deduplicates text automatically

**decode(text_pool_id):** Convert pointer to display value
- Input: 42
- Output: "DFW" or "Dallas/Fort Worth"
- Single lookup, cache-friendly

**getMolecule(molecule_key, tenant_id, category):** Get molecule configuration
- Returns structure with values, validation rules, display hints
- Used to populate dropdowns dynamically
- category parameter for embedded_list types

---

## Why This Design Is Brilliant

### Add New Industries Without Code Changes

Want to add a gym membership program?
1. Define molecules: gym_name, visit_date, class_type
2. Create display templates for "Gym Visit" activity
3. Define bonus rules for class attendance
4. **Done. No code changes.**

The UI reads molecules and renders appropriate inputs.
The bonus engine evaluates rules against molecule values.
Everything just works.

### Bonus Engine Is Industry-Agnostic

Bonus rules are criteria on molecule values:
```sql
WHERE activity_date BETWEEN start_date AND end_date
  AND getMolecule('cabin_class') = 'F'
  AND getMolecule('origin_airport') = 'DFW'
```

Change the molecules and you get hotel bonuses:
```sql
WHERE activity_date BETWEEN start_date AND end_date
  AND getMolecule('room_type') = 'SUITE'
  AND getMolecule('hotel_chain') = 'MARRIOTT'
```

**Same bonus engine. Different data. Zero code changes.**

### Performance Through Pointers

Text value "DFW" appears in 1 million activities.

Bad design: 1 million copies of "DFW" = 3MB
Good design: 1 million pointers to one "DFW" = 4MB (INT references)

Plus: Hot airport codes stay in cache. Lightning fast.

### Text Deduplication

The `molecule_text_pool` acts as a universal string deduplicator:
- First activity with "DFW" creates pool entry
- All subsequent activities reference that pool_id
- Works across all molecules and activities
- Automatic garbage collection when no references remain
- Massive storage savings at scale

### Self-Documenting Metadata

The molecule definitions ARE the documentation:
- `label` tells you what it is
- `description` explains its purpose
- `sample_code` shows example value
- `sample_description` explains the example

No separate documentation to maintain. The database IS the spec.

---

## Historical Context - "Million Years Ago"

Bill's previous loyalty system (built in the 1980s) had innovations that inform this design:

### Custom Variable-Length Keys
Instead of UUIDs or auto-increment integers, Bill used packed keys:
- 2-byte tenant
- 3-byte member (within tenant)
- Total: 5-byte composite key
- Self-describing: Parse key to know tenant and member
- No join needed to get tenant from member_id

### 2-Byte Date Fields
Started epoch at December 31, 1959:
- Date stored as days since epoch (SMALLINT)
- 2 bytes covers ±89 years (1870-2048)
- Loyalty programs don't need dates before 1959
- Half the storage of standard 4-byte DATE

### Right-Sizing Data Types
"Why store billions of records with 4-byte INTs when 2-byte SMALLINTs are enough?"

This philosophy permeates current design:
- `tenant_id`: SMALLINT (32K tenants is plenty)
- `member_id`: BIGINT (billions of members)
- Every field sized to its domain
- Compound savings across billions of rows

---

## Key Discoveries

### Session 2025-11-08: Embedded Lists and Column Name Reality

**Embedded Lists Are Category Containers:**
The `sysparm` molecule (system parameters) contains multiple categories:
- redemption_type: F (Fixed), V (Variable)
- redemption_status: A (Active), I (Inactive)
- bonus_type: P (Percentage), F (Fixed)
- bonus_status: A (Active), I (Inactive)

One molecule, many logical lists. No separate tables needed.

**Column Names Are Not Always Intuitive:**
Found that `redemption_rule` table has:
- `redemption_id` (not `rule_id`)
- `redemption_description` (not `description`)

Lesson: ALWAYS check actual schema before writing queries. Never assume.

**The "Target Rookie Mistake":**
When you get "column does not exist" error:
- Table EXISTS
- You're using WRONG column name
- Fix query, don't create new column
- Like typing `lastname` when field is `last_name`

**Router Pattern for Form Submission:**
When one form needs to save to different endpoints based on context:
- Create router function that checks context
- Delegates to appropriate save handler
- Keeps modal markup simple and reusable

### Session 2025-11-05: Display Templates and Molecule Integration

**Display Templates Are View Configurations:**
Each activity type needs templates for:
- How to display existing activities (read-only)
- How to input new activities (form)
- Templates reference molecules to know what fields exist
- UI auto-generates from templates + molecules

**Bonus Criteria Are Molecule Filters:**
Bonus rules have criteria that filter on molecule values:
- Each criterion: molecule_id, operator, value
- Combine criteria with AND/OR logic
- Evaluate against activity's molecule values
- Generic engine, specific rules

### Earlier Sessions: Core Architecture

**Point Expiration Uses Lot-Based Tracking:**
Points are stored in "lots" with expiration dates:
- Earned 1000 points on 2024-01-01, expire 2025-01-01
- Earned 500 points on 2024-02-01, expire 2025-02-01
- Balance = SUM(points WHERE expiration_date > today())
- FIFO expiration (oldest lots expire first)
- No batch jobs - always accurate

**Tier Qualification Is Time-Bounded:**
`member_tier` table stores:
- `member_id`: Who
- `tier_id`: What tier
- `start_date`: When it started
- `end_date`: When it ends
- Current tier = `WHERE current_date BETWEEN start_date AND end_date`
- Historical tiers = all records with date ranges
- Future tiers = records with start_date > today

---

## The Big Picture

This isn't just a loyalty platform. It's a **universal points and promotions engine** that happens to be perfect for loyalty programs.

The same architecture could power:
- Loyalty programs (airlines, hotels, retail)
- Employee incentive programs
- Sales commission tracking
- Customer referral programs
- Gamification platforms
- Any points-and-rewards system

The molecules make it universal.
The temporal design makes it simple.
The pointer architecture makes it fast.
The data-driven behavior makes it configurable.

**That's the secret sauce.**

---

## Version History

- **2025-11-08 21:35:** Added embedded list discoveries, column name lessons, router pattern, "Target rookie mistake"
- **2025-11-05:** Initial version with core principles and molecule system
- **Earlier:** Historical context from Bill's previous systems

---

**This is what makes the system special. Protect these principles in every decision.**
