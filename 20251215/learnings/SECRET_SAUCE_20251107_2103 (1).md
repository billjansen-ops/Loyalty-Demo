# SECRET SAUCE - Core Architectural Principles
**Last Updated:** 2025-11-08 00:00  
**This file ACCUMULATES - add new discoveries, preserve old wisdom**

---

## üéØ Core Architectural Principles

These are the fundamental truths that make this system different from traditional loyalty platforms.

### 1. Temporal-First Design
**Principle:** Activity date is the source of truth, not posting date.

**What This Means:**
- Activities are tied to when they happened in real life (activity_date)
- Points expire based on activity date, not posting date
- Bonuses evaluate based on activity date
- Retro-credit just works (add old activity, bonuses evaluate correctly)

**Why Brilliant:**
- No batch processing needed to "correct" old activities
- Historical accuracy maintained
- Member expectations match reality (flew on Jan 1 = miles expire Jan 1 next year)

**Traditional Systems:**
- Use posting date as source of truth
- Require complex batch jobs for retro-credit
- Lose historical accuracy when dates diverge

### 2. Tiers Are Promotion Rewards (Not Status Fields)
**Principle:** Tier status is earned by being promoted via bonus rules, not by setting a status field.

**What This Means:**
- Member doesn't have a `current_tier` column
- To find tier: query bonus awards for tier promotions
- Tier is a point in time snapshot, not persistent state
- Tier history is automatic (it's in the bonus audit trail)

**Why Brilliant:**
- Tier changes are auditable (who, when, why)
- No need to "sync" tier status
- Can evaluate tier retroactively
- Tier is derived, not stored

**Traditional Systems:**
- Store `member.tier_level = 'GOLD'`
- Require separate tier history table
- Batch jobs to update tier status
- Difficult to audit tier changes

### 3. Everything Is Pointers (Performance)
**Principle:** Store references (IDs), not values. Decode on-demand.

**What This Means:**
- Activity molecules stored as integers (value_id, text_id, airport_id)
- Labels, descriptions decoded when needed
- Values deduplicated (text pool pattern)
- Minimal storage, maximum flexibility

**Why Brilliant:**
- Adding "DL1234" 1,000 times only stores text once (text_pool)
- Changing "Delta Air Lines" label updates everywhere instantly
- Cache-friendly (IDs are small, sequential, predictable)
- Database stays small even with billions of activities

**Example:**
```
activity_detail stores:
  molecule_id: 3 (origin)
  v_ref_id: 42 (MSP's airport_id)

To display:
  decodeMolecule(3, 42) ‚Üí "MSP"
  
Storage: 8 bytes (two integers)
Not stored: "Origin: Minneapolis-St. Paul International Airport (MSP)"
```

### 4. Data Drives Behavior (Not Hardcoded Logic)
**Principle:** Configuration is data, not code.

**What This Means:**
- Point type labels come from molecules (miles vs points vs stars)
- Activity display format comes from templates
- Bonus rules come from database, not if/then logic
- Field labels come from molecule.label

**Why Brilliant:**
- Add new industry without touching code
- Different tenants can have different behaviors
- A/B test display formats by swapping templates
- System is self-documenting (config is visible in admin UI)

**Traditional Systems:**
- Hardcode "miles" in 47 places in code
- Change label requires code deployment
- Can't customize per tenant without feature flags

### 5. Zero Batch Processing (Derive On-Demand)
**Principle:** Calculate what you need, when you need it. Don't pre-compute.

**What This Means:**
- Member balance = SUM(point_lot WHERE member_id)
- Available miles = SUM(point_lot WHERE expire_date > today)
- Current tier = latest tier promotion bonus
- Expiring soon = point_lot query with date filter

**Why Brilliant:**
- Always accurate (no sync issues)
- No batch jobs to "rebuild" balances
- Works at any scale (database indexes handle it)
- Temporal queries work naturally (balance as of date X)

**Traditional Systems:**
- Store `member.balance` field
- Batch job to recalculate balances nightly
- Sync issues between activity and balance
- Can't easily query "balance as of 6 months ago"

### 6. Molecule Abstraction (Universal, Industry-Agnostic)
**Principle:** All domain-specific data flows through the molecule system.

**What This Means:**
- Airlines use: carrier, origin, destination, fare_class
- Hotels use: hotel_brand, check_in_date, room_type, rate_code
- Credit cards use: merchant, category, transaction_type
- All stored the same way: molecule_def + molecule_value_* tables

**Why Brilliant:**
- One bonus engine works for all industries
- One activity display system works for all industries
- Code is completely industry-agnostic
- Adding new industry = configure molecules, no code

**Example:**
```sql
-- Airlines
molecule_key: 'carrier', lookup_table: 'airline'
molecule_key: 'origin', lookup_table: 'airport'

-- Hotels  
molecule_key: 'hotel_brand', lookup_table: 'hotel_brand'
molecule_key: 'room_type', value_kind: 'list'

-- Both use the same:
- activity_detail table
- encodeMolecule() / decodeMolecule() functions
- bonus evaluation engine
- template display system
```

---

## üß¨ The Molecule System Architecture

### Core Concept
Molecules are typed pointers to values. They abstract away the complexity of different value types (lookups, lists, scalars) behind a universal interface.

### Three-Tier Structure

**Tier 1: Definition (molecule_def)**
- Metadata about the molecule
- What is it? (molecule_key: 'carrier')
- What type? (value_kind: 'lookup', scalar_type, etc.)
- Where does it look up? (lookup_table_key: 'airline')
- Label for display (label: 'Carrier Code')

**Tier 2: Values (molecule_value_* tables)**
Different tables for different value types:
- `molecule_value_lookup` - metadata for foreign table lookups
- `molecule_value_text` - list values (fare classes, room types)
- `molecule_text_pool` - deduplicated scalar text (flight numbers, conf codes)
- `molecule_value_numeric` - scalar numbers (rare, most use text_pool)
- `molecule_value_date` - scalar dates
- `molecule_value_boolean` - scalar booleans

**Tier 3: Usage (activity_detail)**
- Which activity? (activity_id)
- Which molecule? (molecule_id)
- Which value? (v_ref_id - points to value in Tier 2)

### Universal Functions

**encodeMolecule(tenantId, moleculeKey, value)**
- Input: Human value ("DL", "MSP", "F")
- Process: Look up molecule type, find/create value reference
- Output: Integer ID (airline_id, airport_id, value_id)

**decodeMolecule(tenantId, moleculeKey, id)**
- Input: Integer ID from v_ref_id
- Process: Look up molecule type, retrieve value
- Output: Human value ("DL", "MSP", "F")

These two functions handle ALL molecule types. Add new type? Update these functions. That's it.

### Why This Design Is Brilliant

**1. Industry Agnostic**
```javascript
// Same code for airlines, hotels, credit cards:
const encoded = await encodeMolecule(tenantId, moleculeKey, value);
const decoded = await decodeMolecule(tenantId, moleculeKey, id);

// Molecule type determined by data, not code
```

**2. Self-Documenting**
```sql
-- Want to know what molecules exist?
SELECT molecule_key, label, value_kind, context 
FROM molecule_def 
WHERE tenant_id = 1;

-- Code doesn't know about molecules
-- Configuration tells code what exists
```

**3. Performance**
- activity_detail stores only integers (8 bytes per molecule)
- Text deduplicated (store "DL1234" once, reference 1M times)
- Lookups use foreign table indexes (airport table already indexed)
- Cache-friendly (sequential integer IDs)

**4. Flexibility**
- Change label "Carrier Code" ‚Üí "Airline" updates everywhere
- Add new lookup table for hotel brands (just configuration)
- Switch from list to lookup without changing activity_detail
- Historical data automatically uses new labels

---

## üé® Template-Driven Display System

### New Discovery (Session 2025-11-07)

**Principle:** Display format is configuration, not code.

### How It Works

**Step 1: Define Template**
Admin creates template in UI using Line Builder:
```
Line 1: [M,origin,"Code"],[T," ‚Ä¢ "],[M,destination,"Code"]
Line 2: [M,carrier,"Code"],[T," "],[M,flight_number,"Code"]
```

**Step 2: Store Template**
```sql
display_template:
  template_id: 1
  template_name: "Efficient Flight View"
  template_type: "E"

display_template_line:
  template_id: 1, line_number: 10
  template_string: '[M,origin,"Code"],[T," ‚Ä¢ "],[M,destination,"Code"]'
```

**Step 3: Render Template**
Server loads template and decoded molecules, renders:
```
MSP ‚Ä¢ BOS
DL 1234
```

### Why Brilliant

**Before (Hardcoded):**
```javascript
// Hardcoded in server
result.magic_box = [
  { label: 'Origin', value: origin },
  { label: 'Destination', value: destination }
];
```

**After (Template-Driven):**
```javascript
// Server loads template, renders based on config
const template = await loadTemplate('E', tenantId);
result.magic_box = renderTemplate(template, decodedMolecules);
```

**Benefits:**
- Change format without code deployment
- A/B test displays by swapping templates
- Different tenants can have different formats
- Template is visible in admin UI (self-documenting)

### The "Magic Box" Pattern

**Principle:** Activity details render from template + decoded molecules, not hardcoded HTML.

**What It Is:**
The "magic box" is the area where activity details display (e.g., "MSP ‚Ä¢ BOS ‚Ä¢ DL ‚Ä¢ 3331 ‚Ä¢ F"). It's called "magic" because:
- Same data ‚Üí multiple views (Efficient vs Verbose)
- Template-driven (change format without code)
- Molecule-powered (decoded on-demand)

**Implementation:**
```javascript
// Server returns both efficient and verbose views
activity.magic_box_efficient = renderTemplate(efficientTemplate, molecules);
activity.magic_box_verbose = renderTemplate(verboseTemplate, molecules);

// Client toggles between views
if (viewMode === 'verbose') {
  display(activity.magic_box_verbose);
} else {
  display(activity.magic_box_efficient);
}
```

**Template Syntax:**
- `[M,molecule_key,"format"]` - Insert decoded molecule value
- `[T,"text"]` - Insert literal text
- Format options: "Code", "Description", "Both"

**Example Templates:**

Efficient (1 line):
```
[M,origin,"Code"],[T," ‚Ä¢ "],[M,destination,"Code"],[T," ‚Ä¢ "],[M,carrier,"Code"]
```
Renders: `MSP ‚Ä¢ BOS ‚Ä¢ DL`

Verbose (3 lines):
```
Line 1: [M,origin,"Code"],[T," to "],[M,destination,"Code"]
Line 2: [M,carrier,"Description"],[T," ‚Ä¢ "],[M,flight_number,"Code"]
Line 3: [M,fare_class,"Description"]
```
Renders:
```
MSP to BOS
Delta Air Lines ‚Ä¢ 3331
First Class
```

**Why Brilliant:**
- One activity ‚Üí multiple presentations
- Toggle views without re-fetching data
- Templates stored in DB (configuration, not code)
- Tenant-specific formats without code changes

### The "Bonus Box Line Builder" Pattern

**Principle:** Structured calculation display using molecule labels for flexibility.

**What It Is:**
The "bonus box" shows the breakdown of points earned (base + bonuses = total). It's called a "line builder" because it constructs formatted lines dynamically using labels from molecules.

**Implementation:**
```javascript
// Get labels from molecule configuration
const activityTypeLabel = activity.activity_type_label;  // "Flight"
const pointTypeLabel = activity.point_type;              // "miles"

// Build calculation lines
const lines = [
  `${activityTypeLabel} ${pointTypeLabel}:    ${baseMiles}`,
  ...bonuses.map(b => `  ${b.label}    ${b.amount}`),
  `Total ${pointTypeLabel} Added:    ${totalMiles}`
];
```

**Visual Format:**
```
Flight miles:           3,000
  bills test bonus        200
  First Class Test        100
Total miles Added:      3,300
```

**Key Features:**
1. **Label-driven:** Uses `activity_type_label` and `point_type` from molecules
2. **Right-aligned:** Numbers form clean column using monospace font
3. **Indentation:** Bonus lines indented for hierarchy
4. **Consistent styling:** Same green color, same font size throughout

**Why Brilliant:**
- Adapts to different point types (miles/points/stars) automatically
- Adapts to different activity types (Flight/Stay/Purchase) automatically
- No hardcoded "miles" or "Flight" strings in code
- Visual hierarchy (base ‚Üí bonuses ‚Üí total) matches mental model
- Column alignment maintained even when labels change

**Example with Different Labels:**
```
Hotel Stay points:      5,000
  Weekend Bonus         1,000
  Elite Bonus           2,500
Total points Added:     8,500
```

Same code, different configuration, different output.

---

## üèóÔ∏è Historical Context - Bill's "Million Years Ago" Philosophy

### The 2-Byte Date Story
Bill built systems "million years ago" that:
- Used 2-byte dates (days since 12/31/1959)
- Supported dates from 1960 to 2139 (179 years)
- Fit in 16 bits (0 to 65,535)
- Cache-friendly, comparison-friendly

**Philosophy:** Right-size data types to domain.

Don't use:
- `BIGINT` when `INTEGER` works
- `TEXT` when `VARCHAR(20)` works  
- `TIMESTAMP` when `DATE` works
- `DECIMAL` when `INTEGER` (cents) works

**Why:** 
- Smaller = faster
- Smaller = more fits in cache
- Smaller = less network bandwidth
- Smaller = lower storage costs

### Pointer-Based Relationships
"Million years ago" systems used:
- Sequential integer IDs for everything
- Foreign keys everywhere
- Normalized to eliminate duplication
- Lookup tables for reference data

**Bill's systems were:**
- Fast (cache-friendly integer operations)
- Space-efficient (no duplication)
- Flexible (change label, ripples everywhere)
- Auditable (foreign keys enforce integrity)

**Modern ORM systems are:**
- Slow (object overhead, lazy loading)
- Space-wasteful (duplicate text everywhere)
- Rigid (denormalized for "performance")
- Fragile (no referential integrity)

**This loyalty platform follows Bill's philosophy:**
- Everything is pointers (molecule_id, value_id, airport_id)
- Right-sized types (SMALLINT for tenant_id, BIGINT for activity_id)
- Temporal-first (activity_date is source of truth)
- Zero batch processing (derive on-demand)

---

## üí° Key Discoveries by Session

### Session 2025-11-07: Template System & Efficient APIs

**Discovery 1: Template-Driven Display**
- Realized display format should be configuration, not code
- Implemented Line Builder for template creation
- Server now renders magic_box from templates
- Impact: Change display without code changes

**Discovery 2: Efficient API Calls**
- Frontend was loading full molecule data just for sample values
- Added `return_type=with_samples` parameter
- Reduced payload from 500+ bytes to 100 bytes
- Impact: 5x smaller payloads for template previews

**Discovery 3: Sample Data Architecture**
- Molecules need sample data for template previews
- Added sample_code and sample_description to molecule_def
- Sample data used for previews, not live rendering
- Impact: Templates can preview without loading full datasets

**Discovery 4: Graceful Degradation**
- Missing molecules should not crash system
- Added try-catch with sensible defaults
- Bad legacy data handled with safety checks
- Impact: System works even with incomplete configuration

**Discovery 5: Verification Before Destruction**
- NEVER assume database names for DELETE/DROP operations
- ALWAYS verify configuration before destructive commands
- One wrong guess can destroy production data
- Impact: Safety protocol added to workflow standards

---

## üåü Why This System Is Special

### Compared to Traditional Loyalty Platforms

**Traditional Platform:**
- Hardcoded "miles" in 100 places
- Batch job runs nightly to update balances
- Tier is a status field on member table
- Change display requires code deployment
- Each industry needs separate codebase
- Retro-credit requires complex corrections

**This Platform:**
- "miles" comes from molecule (change once, ripples everywhere)
- Balance calculated on-demand (always accurate)
- Tier derived from bonus history (auditable)
- Change display by editing template in UI
- One codebase works for all industries (molecule config)
- Retro-credit just works (temporal-first design)

### The Holy Grail Achievement

**Goal:** Build a loyalty platform that works for ANY industry without code changes.

**Airlines:** ‚úÖ Configure carrier, origin, destination molecules  
**Hotels:** ‚úÖ Configure hotel_brand, room_type molecules  
**Credit Cards:** ‚úÖ Configure merchant, category molecules  
**Retail:** ‚úÖ Configure store, product_category molecules  
**Gas Stations:** ‚úÖ Configure fuel_grade, location molecules  

**Same Code. Different Configuration. Zero Deployment.**

---

## üß† Technical Innovations

### 1. Text Deduplication (molecule_text_pool)
**Problem:** Storing "DL1234" one million times wastes space  
**Solution:** Store once, reference via text_id  
**Impact:** 100x storage reduction for repetitive text

### 2. Metadata-Driven Lookups (molecule_value_lookup)
**Problem:** Hard-coding airport table into code  
**Solution:** Store table_name, id_column, code_column as data  
**Impact:** Add new lookup tables without code changes

### 3. Template String Rendering
**Problem:** Display formats hardcoded in server  
**Solution:** Mini-language `[M,key,"format"]` `[T,"text"]`  
**Impact:** Configure display in UI, no deployment needed

### 4. Temporal Point Expiration
**Problem:** Points expire based on activity date, not posting date  
**Solution:** Expiration rules use activity_date, not created_at  
**Impact:** Retro-credit automatically calculates correct expiration

### 5. Bonus Engine Eval-by-Date
**Problem:** Adding old activity should evaluate bonuses as-of-date  
**Solution:** evaluateBonuses(activity_id, activity_date, base_miles)  
**Impact:** Historical bonus rules apply correctly to old activities

---

## üìö Architectural Patterns to Preserve

### 1. Never Store Derived Data
**Don't:**
```sql
ALTER TABLE member ADD COLUMN balance INTEGER;
UPDATE member SET balance = (SELECT SUM(...));
```

**Do:**
```sql
-- Derive on-demand
SELECT SUM(accrued) FROM point_lot WHERE member_id = ?
```

### 2. Never Hardcode Labels
**Don't:**
```javascript
const pointType = 'miles';
const activityLabel = 'Flight';
```

**Do:**
```javascript
const pointTypeMolecule = await getMolecule('point_type_label', tenantId);
const pointType = pointTypeMolecule.value;
```

### 3. Never Embed Logic in Code
**Don't:**
```javascript
if (fareClass === 'F') bonus = baseMiles * 0.5;
else if (fareClass === 'J') bonus = baseMiles * 0.25;
```

**Do:**
```sql
-- Store rules in database
SELECT bonus_amount FROM bonus 
WHERE molecule_key = 'fare_class' 
AND code_value = $1;
```

### 4. Never Skip Temporal Dimension
**Don't:**
```sql
created_at TIMESTAMP DEFAULT NOW()
```

**Do:**
```sql
activity_date DATE NOT NULL  -- When it happened in real life
post_date DATE NOT NULL      -- When we learned about it
```

### 5. Never Assume Single Tenant
**Don't:**
```sql
SELECT * FROM molecule_def WHERE molecule_key = 'carrier'
```

**Do:**
```sql
SELECT * FROM molecule_def 
WHERE tenant_id = $1 AND molecule_key = 'carrier'
```

---

## üéì Lessons for Future Architects

### What Makes This Design Last Decades

**1. Separation of Concerns**
- Data (molecules, templates, bonuses)
- Logic (encode/decode, evaluate, render)
- Presentation (templates, UI)

Change one layer without touching others.

**2. Configuration Over Code**
- Add new molecule type: Configure molecule_def
- Add new bonus rule: Configure bonus table
- Add new display format: Configure template

Deploy once. Configure forever.

**3. Derive Everything**
- Balance from point_lot
- Tier from bonus history
- Expiring miles from point_lot + date filter

Single source of truth. No sync issues.

**4. Pointer All The Things**
- Molecule values
- Lookup tables  
- Text pools

Small. Fast. Flexible.

**5. Temporal Thinking**
- activity_date is source of truth
- Retro-credit just works
- Historical queries are natural

Time is first-class citizen.

---

## üöÄ Future Possibilities

### What This Architecture Enables

**Multi-Industry Platform:**
- One codebase, 50 industries
- Configure molecules per tenant
- Deploy once, onboard customers via configuration

**Real-Time Personalization:**
- Templates per member segment
- A/B test display formats
- Change rules mid-day, no downtime

**AI-Powered Optimization:**
- Template strings generated by AI
- Bonus rules optimized by ML
- Display formats adapted to user behavior

**Global Scale:**
- Tenant isolation built-in
- Pointer-based design = cache-friendly
- Derive-on-demand = no batch bottlenecks

**Audit & Compliance:**
- Every bonus has audit trail
- Tier changes are explicit
- Point movements are immutable

---

## üîÆ The Vision

**Bill's "million years ago" philosophy meets modern scale.**

This isn't just a loyalty platform. It's a proof that:
- Old wisdom still works (pointers, right-sizing, temporal thinking)
- Data-driven beats code-driven (molecules, templates, rules as data)
- Simplicity scales (encode/decode, evaluate, render)

**The platform that works for airlines, hotels, credit cards, and industries that don't exist yet.**

**Zero batch processing. Zero hardcoded logic. Zero deployment for new industries.**

**Just configuration. Just pointers. Just time.**

---

**This is the secret sauce. Preserve it. Build on it. Never compromise it.**
