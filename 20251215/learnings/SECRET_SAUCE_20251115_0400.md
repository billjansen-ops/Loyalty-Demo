# SECRET SAUCE
**Updated:** November 15, 2025 04:00
**Version:** 20251115_0400 (Emergency handoff - see SESSION_SUMMARY for gap info)

This document ACCUMULATES - each session adds discoveries, never removes old ones.

---

## ğŸ—ï¸ Core Architectural Principles

### 1. Temporal-First Design
**Insight:** Time windows are the primary organizing principle.

```
activity_date determines:
â”œâ”€â”€ Which expiration rule applies
â”œâ”€â”€ Which tier qualification rules apply
â”œâ”€â”€ Which bonus rules are active
â””â”€â”€ When points expire

NO BATCH PROCESSING NEEDED - everything derives on-demand from dates
```

**Why this is brilliant:**
- Retro-credit "just works" - add old activities, points go to right buckets
- Tier recalculations happen automatically based on date windows
- No nightly jobs to sync state
- Audit trail is inherent (everything timestamped)

### 2. Tiers Are Promotion Rewards (Not Status Fields)
**Traditional approach (WRONG):**
```sql
member.tier_status = 'GOLD'  -- Status field, updated by batch job
```

**This system (RIGHT):**
```sql
-- Tier is a promotion reward during a time window
promotion_reward.reward_key = 'tier_gold'
promotion_reward.start_date = '2025-01-01'
promotion_reward.end_date = '2025-12-31'
```

**Why this is brilliant:**
- Tier is derived, not stored
- Historical tier status is automatic
- Member can have multiple overlapping tiers for different programs
- No batch jobs to maintain status
- Audit trail is complete

### 3. Everything Is Pointers (Performance)
**Store IDs, not text. Decode on read.**

```
Activity Detail Storage:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ activity_id â”‚ molecule_id â”‚ v_ref_id â”‚  â† 12 bytes per detail
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     1001    â”‚      7      â”‚    42    â”‚  Instead of "Delta Air Lines"
â”‚     1001    â”‚      8      â”‚   125    â”‚  Instead of "Minneapolis"
â”‚     1001    â”‚      9      â”‚    88    â”‚  Instead of "Boston"
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why this is brilliant:**
- Text deduplication (store "Delta" once, reference everywhere)
- Cache-friendly (integers fit in CPU cache)
- Fast joins (integer comparison vs string comparison)
- Space efficient (12 bytes vs potentially 100+ bytes)
- Easy to change labels without touching transactional data

### 4. Data Drives Behavior (Not Hardcoded Logic)
**Wrong:**
```javascript
if (activity.carrier === 'DL') {
  label = 'Delta Air Lines';
  bonus = activity.distance * 1.5;
}
```

**Right:**
```javascript
const carrierLabel = await decodeMolecule(tenantId, 'carrier', v_ref_id);
const bonusRules = await getBonusRules(tenantId, activity_date);
const bonus = applyRules(activity, bonusRules);
```

**Why this is brilliant:**
- Add new carriers without code changes
- Change bonus rules in database, no deployment
- Multiple tenants with different rules
- Business users can configure, not developers

### 5. Zero Batch Processing
**Traditional loyalty systems:**
```
23:00 - Expire points
01:00 - Recalculate tiers  
03:00 - Process bonuses
05:00 - Send emails
```

**This system:**
```
Everything is on-demand:
- Points expire? Check expire_date when querying
- Tier status? Derive from promotion_rewards
- Bonuses? Calculate when activity posted
- Balances? SUM on query
```

**Why this is brilliant:**
- No batch job failures
- No waiting for overnight processing
- Real-time everything
- Simpler infrastructure
- Easier testing

### 6. Molecule Abstraction (Universal, Industry-Agnostic)
**The key innovation:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ACTIVITY (Universal)         â”‚
â”‚  activity_id, member_id, date, type  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  ACTIVITY_DETAIL (Pointers to molecules)  â”‚
        â”‚  activity_id, molecule_id, v_ref_id       â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  MOLECULE_DEF       â”‚
    â”‚  "carrier"          â”‚â”€â”€â”€â”€â–º molecule_value_text: "Delta", "United", ...
    â”‚  "hotel_brand"      â”‚â”€â”€â”€â”€â–º molecule_value_text: "Marriott", "Hilton", ...
    â”‚  "rental_company"   â”‚â”€â”€â”€â”€â–º molecule_value_text: "Hertz", "Avis", ...
    â”‚  "redemption"       â”‚â”€â”€â”€â”€â–º molecule_value_lookup: redemption_rule table
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why this is brilliant:**
- Same activity table for airlines, hotels, rental cars
- Add new industry: just add molecules
- No schema changes for new activity types
- Bonus engine works for any industry
- Display templates are molecule-driven

### 7. Activity Types Are Molecule-Driven
**Discovery from November 10, 2025:**

All activity type display properties come from `activity_display` embedded_list molecule:
- Icon (âœˆï¸, ğŸ, etc.)
- Colors (green, red, blue)
- Behaviors (show_bonuses flag)
- Text (action_verb: "Added", "Redeemed")

**Wrong approach:**
```javascript
const icon = activity_type === 'R' ? 'ğŸ' : 'âœˆï¸';  // Hardcoded
```

**Right approach:**
```javascript
const displayConfig = await getMolecule('activity_display', tenantId, activity_type);
const icon = displayConfig.icon;  // From molecule
```

**Why this is brilliant:**
- Add new activity type: add rows to molecule, zero code changes
- Change icon/colors: update molecule, no deployment
- Tenant-specific display: different molecules per tenant
- Separates display from business logic

**Special case:** Core activity type ('A') label comes from `activity_type_label` molecule because it defines the fundamental loyalty currency (miles, points, kilometers).

### 8. Molecule Type Taxonomy (November 13, 2025) ğŸ†•
**Problem:** Old classification (scalar/list/lookup/embedded_list) mixed storage with behavior.

**New taxonomy - Three main types:**

```
STATIC - Configuration values (rarely change)
â”œâ”€â”€ Single Value: "Miles", 365, true
â””â”€â”€ Embedded List: Categories with values (activity_display)

DYNAMIC - User-entered or frequently changing data
â”œâ”€â”€ Lookup (Internal): Pre-defined list (fare classes)
â”œâ”€â”€ Lookup (External): References table (carriers, airports)
â””â”€â”€ Freeform: User types value (confirmation numbers)

REFERENCE - Computed/derived values
â”œâ”€â”€ Direct Field: Query table.column (member.fname)
â””â”€â”€ Function: Call stored function (get_tier_on_date)
```

**Why this is better:**
- **Progressive disclosure** - UI shows only relevant fields
- **Clear intent** - Type tells you how the data behaves
- **Industry-agnostic** - Works for any domain
- **Consistent patterns** - Easier to understand

**Backward compatibility:** Maps cleanly to old taxonomy:
- Static/Single Value = scalar
- Static/Embedded List = embedded_list
- Dynamic/Lookup Internal = list
- Dynamic/Lookup External = lookup
- Dynamic/Freeform = scalar (with user input)
- Reference = new concept

**Design decision (Nov 13):** Core dropdown values (Context, Type, Data Type) stay hardcoded. They're architectural constants, not configuration. Sysparm is for business data that evolves.

---

## ğŸ” CSR Bonus Testing & Debugging (GAME CHANGER)
**Added:** November 11, 2025
**Status:** Major competitive differentiator - possibly unique in the industry

### The Problem This Solves

**Traditional loyalty systems:**
```
CSR: "Why didn't this member get the First Class bonus?"
Developer: "Let me check the logs... run some SQL... look at the code..."
[2 hours later]
Developer: "The flight was in Economy, not First Class"
CSR: "But the member claims they flew First. Can you fix it?"
Developer: "I'll need to create a manual adjustment ticket..."
[3 days later - still not resolved]
```

**Airlines have HUNDREDS of active promotions.**
- "Fly to Europe, get double miles"
- "First class on Tuesdays, get 50% bonus"
- "Book direct, get 500 bonus miles"
- "Status match challenge - 5,000 mile bonus after 3 flights"

**Without testing tools:**
- CSRs can't diagnose why bonuses didn't apply
- Members get frustrated waiting for answers
- Developers spend hours debugging individual cases
- Manual adjustments create audit trail nightmares

### The Solution: Real-Time Bonus Testing

**What we built:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Activity Detail Screen                             â”‚
â”‚                                                      â”‚
â”‚  Flight: DL 123, JFK â†’ LAX, 11/11/2025             â”‚
â”‚  Fare Class: Y (Economy)                            â”‚
â”‚  Miles Earned: 2,500                                â”‚
â”‚                                                      â”‚
â”‚  Bonuses Applied: 0                                 â”‚
â”‚                                                      â”‚
â”‚  [ğŸ§ª Test Bonus]  â† CSR clicks this                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Test Bonus Rule                                    â”‚
â”‚                                                      â”‚
â”‚  Select Bonus: [First Class 50% Bonus      â–¼]      â”‚
â”‚                                                      â”‚
â”‚  [Test Rule!]                                       â”‚
â”‚                                                      â”‚
â”‚  âŒ FAIL                                            â”‚
â”‚  Reason: Fly First: Failed                          â”‚
â”‚  Expected: F (First Class)                          â”‚
â”‚  Actual: Y (Economy)                                â”‚
â”‚                                                      â”‚
â”‚  [Close]                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**If the test PASSES (bonus should have been awarded):**
```
âœ… PASS
All criteria matched!

[Apply Bonus Now]  â† CSR can manually apply
```

**Technical Innovation:**
```javascript
// Shared function used by BOTH automatic AND manual
async function applyBonusToActivity(...) {
  // Calculate, create record, update points
}

// Automatic evaluation calls it
evaluateBonuses() {
  if (criteriaPass) await applyBonusToActivity(...);
}

// Manual CSR application calls SAME function
POST /apply-bonus {
  await applyBonusToActivity(...);
}
```

**Why This Is HUGE:**
- Test and production can NEVER diverge (same code)
- CSRs empowered to diagnose AND fix issues
- No developer escalation needed
- Instant member satisfaction
- Learning tool for new CSRs

**Critical Bug Fixed:** Bonus engine wasn't selecting `rule_id` from database, so it NEVER checked criteria and awarded EVERY active bonus. Adding `rule_id` to SELECT statement fixed it.

**Why This Matters:**
- **Competitive advantage** - Most loyalty systems can't do this (batch processing, monolithic code)
- **Operational excellence** - Empowers CSRs, delights members
- **Architectural proof** - Data-driven design enables features impossible in traditional systems

**The secret sauce:** Making the invisible visible. Making the automatic testable. Making the complex simple.

---

## ğŸ”§ LONGORIA Command (November 12-13, 2025) ğŸ†•
**What:** Special maintenance command for auditing and optimizing admin pages
**Why named LONGORIA:** Has no default meaning - forces Claude to ask if forgotten instead of guessing wrong

### The Three Checks

**1. Apply Vertical Spacing Standards**
```
Form section padding:     6px (not 16px+)
Margins between sections: 6px (not 12px+)
Input/textarea padding:   6px 8px
Textarea min-height:      40px (not 60px+)
Table cell padding:       6px 8px
Action buttons margin:    8px
Icon-only buttons:        4px 8px padding, 14px font
```

**Action Button Standards:**
- Default to icon-only (âœï¸ ğŸ—‘ï¸ âœ…)
- Title attributes for tooltips
- Text buttons only for primary actions

**Test:** With 1500px height, form fits without scrolling

**1b. Scrollable List Pattern (Added Nov 12)**
```html
<div class="table-scroll-wrapper">
  <table>
    <thead><!-- Sticky headers --></thead>
    <tbody><!-- Scrollable data --></tbody>
  </table>
</div>
```

```css
.table-scroll-wrapper {
  max-height: calc(100vh - 320px);
  overflow-y: auto;
}

th {
  position: sticky;
  top: 0;
  z-index: 100;
  background: #f9fafb;  /* CRITICAL: Solid background */
  border-bottom: 2px solid #e5e7eb;
}
```

**Key principles:**
- Page header stays fixed
- Table headers remain visible while data scrolls
- Headers MUST have solid background
- High z-index (100+)
- Bottom border for visual separation
- Icon-only buttons in rows

**2. Audit for Molecule Violations**
- No hardcoded dropdown options
- Use molecule_key not molecule_id
- No hardcoded labels
- No direct SQL to molecule tables
- No hardcoded tenant values

**3. Verify Back Button**
- "â† Back" button exists
- Correct placement (bottom-left)
- Always visible

**Success:** Page fits in viewport, no hardcoded values, back button works.

**Why this is brilliant:**
- Consistent UX across all admin pages
- No more wasted vertical space
- Molecule-first thinking enforced
- Scrollable lists work perfectly

---

## ğŸ’¾ Session Handoff System (November 12-13, 2025) ğŸ†•
**Problem:** Claude forgets everything between sessions. Need way to transfer knowledge.

**The Innovation:** Four-file system with timestamps

```
END OF CHAT:
â”œâ”€â”€ START_CHAT_INSTRUCTIONS_YYYYMMDD_HHMM.md (How to boot)
â”œâ”€â”€ SESSION_SUMMARY_YYYYMMDD_HHMM.md (What happened today)
â”œâ”€â”€ WORKFLOW_STANDARDS_YYYYMMDD_HHMM.md (How we work) â† ACCUMULATES
â””â”€â”€ SECRET_SAUCE_YYYYMMDD_HHMM.md (Why this is brilliant) â† ACCUMULATES

Bill runs: create_handoff_package.sh
â”œâ”€â”€ Captures schema
â”œâ”€â”€ Copies all files (including above 4)
â””â”€â”€ Creates tarball

START NEW CHAT:
â”œâ”€â”€ Upload START_CHAT_BOOTSTRAP.md
â”œâ”€â”€ Upload handoff tarball
â”œâ”€â”€ New Claude extracts
â”œâ”€â”€ Uses `ls -t` to find latest versions
â””â”€â”€ Reads all 4 files
```

**Why this works:**
- **ACCUMULATION** - Standards and sauce grow over time
- **TIMESTAMPS** - Always find latest version
- **SELF-PERPETUATING** - Each session creates files for next session
- **COMPLETE CONTEXT** - New Claude has everything

**Key insight:** Files 3 and 4 (WORKFLOW_STANDARDS and SECRET_SAUCE) NEVER get replaced, only extended. This preserves all learnings across sessions.

**The ATIS system:** Simple phrase in conversation ("ATIS Alpha is current") - tests context retention objectively.

**Why this is necessary:**
- Claude has no memory between chats
- Token limits force chat rotation
- Knowledge must transfer seamlessly
- Standards must persist
- Learnings must accumulate

**This solves the AI amnesia problem.**

---

## ğŸ¯ Historical Context: "Million Years Ago"

### Bill's Original System (1980s-90s)
**Data type philosophy from the beginning:**

```
Custom variable-length keys: 1-4 bytes (not BIGINT everywhere)
2-byte dates: Days since 12/31/1959 (Bill's birthday!)
Coverage: 1960-2139 (179 years)
Philosophy: Right-size every field to actual domain needs
```

**These principles inform current architecture:**
- Deliberate data type choices
- Cache-friendly designs  
- Pointer-based relationships (IDs not strings)
- Performance-first approach

**The eternal truth:** Performance comes from right-sizing, not premature optimization.

---

## ğŸ“š Key Discoveries

### Discovery 1: Bonus Engine Requires rule_id (November 11, 2025)
**Bug:** Bonus criteria were NEVER checked - every active bonus applied
**Fix:** SELECT rule_id from bonus table (was missing)
**Lesson:** Always verify query returns necessary columns

### Discovery 2: Temporal-First Enables Retro-Credit (November 10, 2025)
Post old activities â†’ they find correct buckets based on activity_date
No batch processing needed

### Discovery 3: Display Templates Are Just Molecule Maps (November 10, 2025)
```javascript
{
  "origin": "Origin",      // Molecule key â†’ Display label
  "dest": "Destination",
  "carrier": "Carrier"
}
```
Template = list of molecules to display. That's it.

### Discovery 4: Redemptions Are Molecules Too (November 10, 2025)
```sql
-- Create redemption molecule (lookup to redemption_rule table)
INSERT INTO molecule_def VALUES (..., 'redemption', 'Redemption Type', 'lookup', 'activity');

-- Store in activity_detail
INSERT INTO activity_detail (activity_id, molecule_id, v_ref_id)
VALUES (activity_id, redemption_molecule_id, redemption_rule_id);
```

**Why this matters:**
- Follows established pattern (same as carrier)
- No schema changes to core tables
- Extensible for future activity types
- Data-driven, not hardcoded

**The rule:** Only add columns for core activity data (date, type, amount). Everything else goes in activity_detail as molecules.

### Discovery 5: Redemption Aging Display (November 10, 2025)
**Problem:** Need to show how redemption points were allocated across buckets
**Solution:** Query redemption_detail + point_lot, group by expire_date

**Why this is useful:**
- Shows member exactly which buckets were used
- Demonstrates FIFO allocation working correctly
- Transparent point consumption
- Could be used for "undo" functionality in future

### Discovery 6: CSS Grid Complexity (November 10, 2025)
**Problem:** CSS Grid creating huge whitespace despite various settings
**Lesson:** Simple layouts don't need complex CSS

**What we tried:**
1. `grid-template-columns: 1fr auto` â†’ 10+ inches of whitespace
2. `grid-template-columns: auto auto` â†’ still huge whitespace
3. `margin-left: 20px` â†’ worked perfectly

**The principle:**
- Don't reach for complex CSS (Grid, Flexbox) for simple spacing
- Use basic margin/padding when appropriate
- Test whitespace early - browser rendering can be unpredictable
- Simple beats complex

### Discovery 7: Progressive Disclosure for Molecule Edit (November 13, 2025) ğŸ†•
**Problem:** Molecule edit page needs to handle 8+ different configurations
**Solution:** Show only relevant fields based on Type/Subtype selection

**The pattern:**
```javascript
// Type changes â†’ show Type config section
moleculeType.onChange(() => {
  hideAll();
  if (type === 'static') show('staticConfig');
  if (type === 'dynamic') show('dynamicConfig');
  if (type === 'reference') show('referenceConfig');
});

// Subtype changes â†’ show Subtype fields
staticSubtype.onChange(() => {
  if (subtype === 'single_value') show('staticSingleValue');
  if (subtype === 'embedded_list') show('staticEmbeddedList');
});
```

**Why this works:**
- User never overwhelmed
- Clear workflow (top to bottom)
- Only sees relevant options
- Self-documenting (form structure explains molecule types)

### Discovery 8: Endpoint Design Philosophy (November 13, 2025) ğŸ†•
**Question:** Should we add new focused endpoints or reuse existing ones that return more data?

**Decision:** Add focused endpoints when they're cleaner

**Example:**
- OLD: `/v1/molecules/get/:key` returns full molecule + all categories + values
- NEW: `/v1/molecules/:id/embedded-categories` returns just category list
- NEW: `/v1/molecules/:id/embedded-values?category=X` returns values for one category

**Why:**
- Simpler for client code
- More RESTful
- Easier to understand
- Can optimize queries independently
- Better for API documentation

**The principle:** Don't be afraid to add endpoints for clarity. Reuse is good, but not at expense of API clarity.

### Discovery 9: Reference Type Implementation (November 13-14, 2025) ğŸ†•
**Problem:** New taxonomy includes Reference types (direct_field, function) but no storage exists.

**Solution:** Add columns to molecule_def instead of new table.

```sql
ALTER TABLE molecule_def 
ADD COLUMN ref_table_name TEXT,    -- For direct_field: "member"
ADD COLUMN ref_field_name TEXT,    -- For direct_field: "fname"
ADD COLUMN ref_function_name TEXT; -- For function: "get_member_tier_on_date"
```

**Why this approach:**
- Consistent with existing `lookup_table_key` column pattern
- Simpler queries (no joins needed)
- molecule_def is only stored once per tenant, so extra columns don't hurt performance
- Could add hundreds of columns without impact (though we won't)

**When Bill asked:** "Don't we already have a spot to store table/field names?" - he was checking if we were duplicating storage. We clarified that external lookups (molecule_value_lookup) are semantically different from references.

**External Lookup vs Reference:**
- External Lookup: Points to TABLE with MANY rows (carriers, airports) â†’ Returns list of choices
- Reference/Direct Field: Points to SINGLE FIELD in specific row (member.fname) â†’ Returns one value
- Reference/Function: Calls stored function â†’ Returns computed value

### Discovery 10: Consistent Value Loading Pattern (November 13-14, 2025) ğŸ†•
**Problem:** When editing molecules, some types loaded their values, others didn't.

**The systematic fix:**
```javascript
// Static/Single Value
loadScalarValue(moleculeId) â†’ GET /v1/molecules/:id/value

// Static/Embedded List  
loadEmbeddedCategories(moleculeId) â†’ GET /v1/molecules/:id/embedded-categories
loadCategoryValues(category) â†’ GET /v1/molecules/:id/embedded-values?category=X

// Dynamic/Lookup Internal
loadListValues(moleculeId) â†’ GET /v1/molecules/:id/values

// Dynamic/Lookup External
loadLookupConfig(moleculeId) â†’ GET /v1/molecules/:id/lookup-config

// Reference types
Load from molecule_def fields directly (ref_table_name, etc.)
```

**Why this matters:**
- User sees complete molecule configuration when editing
- No surprises (missing values that actually exist)
- Consistent UX across all types
- Each type has its own focused loading function

**The principle:** Every molecule type that CAN have configuration MUST load it consistently.

### Discovery 11: Handoff File Timing (November 13-14, 2025) ğŸ†•
**Critical learning:** Don't create handoff files until session is ACTUALLY complete.

**What went wrong:**
1. Created handoff files mid-session (when Bill said "let's create handoff")
2. Continued working for 1+ hour after creating files
3. Handoff files claimed things were incomplete that we actually completed
4. Next Claude would have wrong understanding of current state

**The correct process:**
1. Bill says "create handoff files" only when ACTUALLY ending session
2. Handoff files must reflect FINAL state, not mid-session state
3. SESSION_SUMMARY must list what's ACTUALLY working, not what was working 2 hours ago

**Why this matters:**
- Handoff files are source of truth for next Claude
- Wrong information = next Claude wastes time re-doing completed work
- Or worse: next Claude "fixes" things that aren't broken

**The principle:** Handoff files are the last thing you do, not something you do when told unless Bill is actually ending the session.

---

## ğŸ”® Future Innovations (Ideas for Next Sessions)

### 1. Molecule-Driven Tier Thresholds
```sql
-- Instead of hardcoded tier rules
CREATE TABLE tier_threshold (
  threshold_id SERIAL PRIMARY KEY,
  tenant_id SMALLINT,
  tier_molecule_id INTEGER,  -- References molecule_def
  points_required INTEGER,
  valid_from DATE,
  valid_to DATE
);
```

### 2. Calculated Molecules
```sql
-- Molecule that derives value from other molecules
molecule_key = 'total_value'
calculation = 'base_miles * multiplier + bonus'
```

### 3. Molecule Versioning
```sql
-- Track changes to molecule values over time
molecule_value_text_history (
  history_id,
  text_id,
  text_value,
  valid_from,
  valid_to
);
```

### 4. Cross-Tenant Molecule Sharing
```sql
-- Some molecules could be shared across tenants
molecule_def.scope = 'tenant' | 'global'
-- Airport codes are same for everyone
```

### 5. Activity Type Extensions
```
Add more types to activity_display:
- 'T' (Transfer) - move points between programs
- 'X' (Adjustment) - manual corrections
- 'B' (Bonus) - standalone bonus credits
- 'E' (Expiration) - point expiry activity

Just add rows to molecule - no code changes!
```

### 6. Admin UI for Activity Display
Build UI to edit activity_display molecule rows instead of SQL.

### 7. Member Profile Navigation
```javascript
// Disable/gray out member-specific links when no member selected
if (!memberId) {
  navItem.classList.add('disabled');
  navItem.style.pointerEvents = 'none';
  navItem.style.opacity = '0.5';
}
```

---

## ğŸ“ Lessons Learned

### What Works
1. **Read schema first** - saves hours of mistakes
2. **Test incrementally** - catch issues early
3. **Helper functions** - avoid duplication
4. **Data-driven everything** - flexibility without code changes
5. **Right-size types** - performance matters
6. **Complete files** - never ask Bill to edit
7. **Molecule-first thinking** - everything display-related is a molecule
8. **Progressive disclosure** - show only what's needed
9. **Accumulating standards** - don't lose knowledge
10. **Focused endpoints** - clarity over reuse
11. **Consistent loading patterns** - every type loads its configuration
12. **Columns in molecule_def** - for architectural metadata that's stored once
13. **Handoff at the END** - create handoff files when session is actually done

### What Doesn't Work
1. **Assuming schema** - always wrong
2. **Hardcoding** - Bill will catch it
3. **Partial files** - wastes Bill's time
4. **Arguing** - Bill is right, adjust
5. **Verbose explanations** - get to the point
6. **Repeating mistakes** - learn from corrections
7. **Adding columns** - use molecules instead (EXCEPT for architectural metadata in molecule_def)
8. **Complex CSS** - simple usually wins
9. **Overly clever code** - readable beats clever
10. **Forgetting context** - use handoff system
11. **Inconsistent loading** - some types loading values, others not
12. **Creating handoff files mid-session** - they become outdated as work continues

### Bill's Wisdom
- "Million years ago" systems teach eternal truths
- Performance comes from right-sizing, not premature optimization
- Data drives behavior, always
- When in doubt, check the actual database
- Code should read like the domain
- Everything display-related belongs in molecules
- When Bill says "stop!" - you're going wrong
- When Bill says "NO!" - fundamental misunderstanding
- "Theoretically we could put hundreds of columns on molecule_def, but we won't - it's only stored once so it won't hurt efficiency"
- Question assumptions about what already exists before building new things
- Favorite color: green ğŸ˜Š

---

## ğŸ“Š System Metrics

### Current Scale (Tenant 1)
- **Members**: Variable (data cleaned)
- **Activities**: Variable (data cleaned)
- **Molecules**: ~30 defined (including activity_display, redemption)
- **Bonus Rules**: ~3 active
- **Display Templates**: 2 (efficient, verbose)
- **Error Codes**: 3 (E001, E002, E003)
- **Activity Types**: 2 ('A', 'R') - ready for more

### Designed Scale
- **Tenants**: 32,000 (SMALLINT max)
- **Members per tenant**: Billions (BIGINT)
- **Activities per member**: Unlimited
- **Molecules per tenant**: 2 billion (INTEGER)
- **Values per molecule**: 2 billion (INTEGER)

### Performance Characteristics
- **Activity lookup**: <10ms (indexed on member_id, activity_date)
- **Molecule decode**: <5ms (cached in memory)
- **Bonus calculation**: <20ms (rule evaluation)
- **Point balance**: <15ms (SUM with indexes)

---

## ğŸš€ The Vision

This isn't just a loyalty platform. It's a **universal points and rewards engine** that can power:

- Airlines (miles, flights, upgrades)
- Hotels (points, stays, room nights)
- Credit cards (cashback, rewards)
- Retail (purchase points, discounts)
- Gaming (XP, achievements, currency)
- Any points-based system

**The secret:** Molecules make it industry-agnostic AND display-agnostic.

**The promise:** Add new industry OR new activity type in hours, not months.

**The reality:** It works, and it's fast.

---

## ğŸ¯ The Molecule Philosophy (Summary)

1. **Core tables store only core data** - activity table has date, type, amount
2. **Everything else is molecules** - industry data, display config, behavior flags
3. **activity_detail is the extension point** - pointers to molecules
4. **Decode on read, encode on write** - store IDs, show text
5. **Data drives everything** - code has no business logic, only molecule application
6. **Add capabilities through data** - not code deployments
7. **Progressive disclosure in UI** - show only what's relevant
8. **Standards accumulate** - preserve knowledge across sessions

**This is the way.**

---

**Bill built something special here. Preserve it. Extend it. But never break it.**
